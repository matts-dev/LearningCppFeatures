#include<iostream>

int main()
{
	//with lambda's, there's 3 dinstinct terms
	//lambda - the expression that gives rise to an expression that generates closures
	//closure - a object made at runtime that can be used to execute the lambda; this is what is called when a lambda is invoked; there can be multiple closures
	//closure class - The class generated by the compiler that defines the closure instance.

	auto closure_instance = []() {std::cout << "hello world" << std::endl; };
	auto closure2 = closure_instance;

	closure_instance();
	closure2();

	// ------------------------------------------------------------------

	struct DemoForClosures { 
		int x = 0;
	};
	DemoForClosures obj;

	//create a closure that stores an object instance as a field and modifies it with calls (note: this is capturing obj by copy)
	auto closureA = [obj]() mutable { obj.x++; std::cout << "count :" << obj.x << std::endl; }; //mutable required to modify x; closures' operator() is defined as a const object
	auto closureB = closureA; //we can see that each copy gets a copy of obj for its own used

	closureA(); //count :1
	closureA(); //count :2
	closureA(); //count :3
	closureA(); //count :4

	closureB(); //count :1

	//will this be 1 or 2?
	auto closureC = closureB; //notice, we're creating this closeure after the fact that we modified the closureB
	closureC(); 
	//answer... count :2!!! this means closure C makesa copy closure_B at closure_B's current state!

	// ------------------------------------------------------------------
	//You can also capture by reference, this mode modifies the contents of the lambda
	auto ClosureWithRef_A = [&obj]() mutable { ++obj.x; std::cout << "reflambda count: " << obj.x << std::endl; };
	auto CloseureWithRef_B = ClosureWithRef_A;

	ClosureWithRef_A();		//	reflambda count : 1
	ClosureWithRef_A();		//	reflambda count : 2
	CloseureWithRef_B();	//	reflambda count : 3

	// ------------------------------------------------------------------

	//you can also specify default capture modes that basically capture everything in the current scope -- though these should be avoided because of bugs (more on that in another .cpp)
	DemoForClosures SomethingToCapture_A;
	DemoForClosures SomethingToCapture_B;

	auto DefaultCapture_ByCopy = [=]() mutable {std::cout << "see, I can refer to an I didn't specify!" << SomethingToCapture_A.x << std::endl; SomethingToCapture_A.x++; };
	auto DefaultCapture_ByCopy_B = DefaultCapture_ByCopy;
	DefaultCapture_ByCopy();	//see, I can refer to an I didn't specify!0
	DefaultCapture_ByCopy();	//see, I can refer to an I didn't specify!0
	DefaultCapture_ByCopy_B();	//see, I can refer to an I didn't specify!1

	auto DefaultCapture_ByReference = [&]() mutable {std::cout << "modifying a reference to something I didn't specify in the capture list!" << SomethingToCapture_B.x << std::endl; SomethingToCapture_B.x++; };
	auto a_copy = DefaultCapture_ByReference;

	DefaultCapture_ByReference(); //modifying a reference to something I didn't specify in the capture list!0
	DefaultCapture_ByReference(); //modifying a reference to something I didn't specify in the capture list!1
	DefaultCapture_ByReference(); //modifying a reference to something I didn't specify in the capture list!2
	a_copy(); //modifying a reference to something I didn't specify in the capture list!3

	std::cin.get();
	return 0;
}